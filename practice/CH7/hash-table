# 해쉬 테이블의 기본적 개념 #

해쉬 테이블은 key에 value를 저장하는 구조로, 원하는 데이터를 한 방에 찾을 수 있다 (O(1))
키를 지정하면 특정한 해쉬 함수에 맞추어서 bucket에 키에 해당하는 Value가 저장되는 형식이다.
해시함수를 사용하여 키를 해시값으로 매핑하고, 이 해시값을 색인(index) 혹은 주소 삼아 데이터의 값(value)을 키와 함께 저장하는 자료구조
하지만, 해쉬 테이블에서는 '해쉬 충돌' 이라고 부르는 근본적인 문제가 존재한다. 
이는 서로 다른 두 개의 입력값에 대해 동일한 출력값을 내는 상황을 의미한다. 
이 해쉬 충돌을 막기 위해 다양한 방법이 동원되고 있다.

# 해쉬 테이블의 종류 #

키의 전체 개수와 동일한 크기의 버킷을 가진 해시테이블을 'direct-address table'
이 경우에는 해쉬 충돌은 없지만 쓰지 않는 키까지 마련해야 하므로 메모리 효율성이 떨어진다.
그래서 보통은 해시테이블 크기가 (m) 실제 사용되는 키 개수 (n) 보다 적은 해시테이블을 제작한다.
여기서 n/m는 load factor라고 하며, 1보다 큰 경우 해쉬충돌이 발생한다.

# 체이닝에 대해서 #

버킷 당 들어갈 수 있는 엔트리 수에 제한을 두지 않는다.
즉, 버킷에 데이터가 이미 있다면 연결리스트처럼 노드를 추가해서 넣어 체인처럼 만든다.
두 키가 한 버켓을 가리키고 있을 때, 동일한 버킷에 두 개 데이터를 저장해서 최근 데이터는 head에 추가
"삽입 복잡성" 은 매핑하고 헤드가 추가하는 데 O(1) + O(1) = "O(1)" 이 된다.
"쿼리값에 해당하는 데이터가 해쉬테이블이 없으면" 버킷의 요소를 다 검사해야 확인 가능하므로 "O(1+개수)"
존재하지만 최악의 경우 (Tail에 데이터 위치), 버킷 개수 - 1 까지 검사해야 하므로 O(1+개수)
정말 최악의 경우 (한 버킷에 모든 데이터가 위치) O(n) 이 될 수도 있다.

# 오픈 어드레싱에 대해서 #

오픈 어드레싱은 한 버킷당 들어갈 수 있는 엔트리가 '하나' 인 해시테이블.
메모리 문제는 딱히 발생하지는 않으나, 해쉬 충돌의 위험이 존재한다.
해시함수에 따라 배열할 때, 만약 이미 다른 값이 해쉬에 있으면 그 다음 빈 곳으로 삽입하는 형식
특정 데이터를 삭제할 
